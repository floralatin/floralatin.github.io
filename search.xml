<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hacker</title>
      <link href="/2023/08/03/hacker/"/>
      <url>/2023/08/03/hacker/</url>
      
        <content type="html"><![CDATA[<h2 id="如何成为一名黑客"><a href="#如何成为一名黑客" class="headerlink" title="如何成为一名黑客"></a>如何成为一名黑客</h2><p>Eric Steven Raymond</p><p>Thyrsus Enterprises</p><p>Copyright © 2001 Eric S. Raymond <a href="mailto:&#x65;&#115;&#x72;&#x40;&#x74;&#104;&#x79;&#114;&#x73;&#117;&#x73;&#46;&#99;&#x6f;&#109;">&#x65;&#115;&#x72;&#x40;&#x74;&#104;&#x79;&#114;&#x73;&#117;&#x73;&#46;&#99;&#x6f;&#109;</a></p><p>Wang Dingwei <a href="mailto:&#x77;&#97;&#110;&#x67;&#x64;&#x69;&#x6e;&#103;&#x77;&#x65;&#x69;&#x38;&#x32;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;">&#x77;&#97;&#110;&#x67;&#x64;&#x69;&#x6e;&#103;&#x77;&#x65;&#x69;&#x38;&#x32;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;</a> 基于 Barret 的翻译更正而成。转载请注明出处。</p><h2 id="为什么会有这份文档？"><a href="#为什么会有这份文档？" class="headerlink" title="为什么会有这份文档？"></a>为什么会有这份文档？</h2><p>作为 Jargon File（译注：黑客行话大全）的编辑和几份其他类似性质知名文章的作者，我经常收到充满热情的网络新手的电子邮件询问：“我如何才能成为一名出色的 Hacker？”早在 1996 年，我注意到网上似乎没有任何的 FAQ 或者 Web 形式的文档提到及这个至关重要的问题，因此我写了这份文档。现在，很多 Hacker 都认为这是一篇权威性文档，那我也姑且这么认为吧。不过，我不认为我是这个话题的绝对权威；如果你不喜欢这篇文档，你也可以自己写一份。</p><p>如果你读到的是这份文档的离线拷贝，你可以在 <a href="http://catb.org/~esr/faqs/hacker-howto.html">http://catb.org/~esr/faqs/hacker-howto.html</a> 读到最新版本。</p><p>注意：文档的结尾有一份 FAQ（常见问题解答）。如果你想通过邮件询问我关于这份文档的问题，请先读这份 FAQ 看看能否找到答案——一遍不行就读两遍。</p><p>目前这份文档有很多翻译版本：阿拉伯语、白俄罗斯语、丹麦语、 荷兰语 、爱沙尼亚语、德语 、希腊语、意大利语 、希伯来语、 挪威语 、葡萄牙语（巴西）、 罗马尼亚语 、西班牙语 、土耳其语、瑞典语 。注意由于这份文档时有修正，所以以上翻译版本可能有不同程度的过时。</p><p>装饰本文的“五点九宫格”图像被称作“glider”，在一种叫做 Life 的数学模型中，这个简单的样本有一些异乎寻常的属性，多年以来 Hacker 们都为此着迷。我认为这个图像是一个很好的黑客徽标：它显得抽象而且神秘，而且像是一扇大门，通向一个截然不同的有其内在逻辑的世界。你可以阅读更多关于 Glider 徽标 的内容。</p><h2 id="什么是黑客？"><a href="#什么是黑客？" class="headerlink" title="什么是黑客？"></a>什么是黑客？</h2><p>Jargon File 讲了一堆关于“hacker”这个词的定义，大部分是关于“技术高超”、“热衷解决问题”、以及“超越极限”的内容。但如果你只想知道如何成为一名黑客的话，真正重要的只有两条。</p><p>这可以追溯到几十年前，那时候第一代分时微型计算机才刚刚诞生, 而 ARPAnet 的实验也才刚展开。那时的编程专家和组网高手建立了一个具有共享性质的文化社群， “hacker” 这个名词就是其中的成员创造的。黑客们建立了互联网，黑客们让 Unix 操作系统演化到现在的模样，黑客们经营着 Usenet，黑客们让万维网运转起来。如果你是这个文化的一部分，如果你对这种文化有所贡献，而且这个社群的其它成员也认识你并称你为 hacker，那么你就是一名黑客。</p><p>黑客的思维方式并不仅仅局限在软件黑客的文化圈内。也有人用黑客态度对待其它事情，如电子和音乐方面——其实你可以在任何最高级别的科学和艺术活动中发现它的身影。软件黑客对这些领域的践行者尊重有加，并把他们也称作黑客——有人宣称黑客天性是绝对独立于他们工作的特定领域的。但在这份文档中，我们将集中书写在软件黑客的技术和态度，以及发明了“黑客”一词的、以共享为特征的文化传统。</p><p>有另外一群人大声嚷嚷着自己是黑客，但他们根本不是。他们主要由青少年男性构成，是一些蓄意破坏计算机和电话系统的人。真正的黑客把这些人叫做“骇客”(cracker)，并不屑与之为伍。黑客们通常认为他们是一群懒散、没有责任心、而且不是很聪明的人。会通过热接线发动汽车并不意味着你是一个汽车工程师。一样的道理，会破坏安全也不意味着你是一名黑客，不幸的是，很多记者和作家往往错把“骇客”当成黑客；这种做法一直使真正的黑客感到恼火。</p><p>根本的区别是：黑客搞建设，骇客搞破坏。</p><p>如果你想成为一名黑客，请接着读下去。如果你想做一个骇客，就去读 alt.2600 新闻组吧，顺便准备好去蹲个五到十年的监狱，而且最终你会意识到你并不像自己想象的那么聪明。</p><p>关于骇客，我能说的只有这些。</p><h2 id="黑客的态度"><a href="#黑客的态度" class="headerlink" title="黑客的态度"></a>黑客的态度</h2><ol><li>这个世界充满了令人着迷的问题等着我们解决。</li><li>一个问题不应该被解决两次。</li><li>无聊和乏味的工作是罪恶。</li><li>崇尚自由。</li><li>态度不能替代能力。<br>黑客们解决问题，建设事物，同时他们信仰自由和无私的双向帮助。要想作为一名黑客被社群认同，你需要体现出自己已经具备了这种态度。而要体现出这种态度，你就得真正相信和赞同这种态度。</li></ol><p>但是，如果你认为培养黑客态度只是进入黑客文化圈的敲门砖，那就大错特错了。这种态度将有助于有助于你的学习，并且能为你提供源源不断的动力，所以它对你而言是至关重要的。和所有创造性的艺术一样，成为大师的最有效方法，就是模仿大师的精神——智力上的模仿还不够，还要从感情上进行模仿。</p><p>或者正如下面这首现代的禅诗讲的：</p><p>修行之道：<br>关注大师的言行，<br>跟随大师的举动，<br>和大师一并修行，<br>领会大师的意境，<br>成为真正的大师。<br>所以，如果你想成为一名黑客，反复读下面的事情直至你相信它们为止：</p><ol><li>这个世界充满了令人着迷的问题等着我们解决。<br>做一名黑客会有很多乐趣，但是这些乐趣需要付出很多努力才能获得。这些努力需要动力。成功的运动员在表演和超越自我极限的时候获得身体上的愉悦，并把这种愉悦作为自己的动力。同样，为了成为一名黑客，你要从解决问题、磨练技术，以及锻炼智力中得到基本的享受。</li></ol><p>如果你不是天性如此，而你又想成为一名黑客，你就要设法成为这样的人。否则你会发现，你的黑客热情会被其他分心的事物吞噬掉——如金钱、性、以及社交圈的认同。</p><p>（你必须建立对于自己学习能力的信念——就算你掌握的知识不足以解决当前的问题，如果你从问题的一小部分下手并从中学习，你将学到足够的知识用来解决下一部分——以此类推，直到整个问题都被你解决为止。）</p><ol start="2"><li>一个问题不应该被解决两次。<br>有创新能力的大脑是一种宝贵的有限资源。当世界还充满非常多有待解决的有趣的新问题时，它们不应该被浪费在重新发明轮子的事情上。</li></ol><p>作为一名黑客，你必须相信其他黑客的思考时间是宝贵的——因此共享信息、解决问题、并发布结果给其他黑客几乎是一种道义，这样其他人就可以去解决新问题，而不用在旧问题上面浪费精力了。</p><p>（这并不是在说你有义务把自己所有的作品都免费发布出来，但这样做的黑客能获得大家最大的尊敬。使用黑客技能养家糊口甚至发财致富都没关系，只要你别忘记自己作为一个黑客的责任，不背离黑客群体即可。）</p><ol start="3"><li>无聊和乏味的工作是罪恶。<br>黑客（以及所有创造力的人们）都不应该被愚蠢的重复性劳动所困扰。重复性劳动浪费了他们解决新问题的时间，而解决新问题正是黑客最大的价值所在。这种浪费会伤害到每一个人。无聊和乏味的工作不仅仅是令人不舒服而已，而且本身就是一种罪恶。</li></ol><p>作为一个黑客，你必须坚信这点并尽可能多地将乏味的工作自动化，这不仅是为了你自己，也是为了其他人（尤其是其他黑客们）。</p><p>(对此有一个明显的例外。黑客有时为了休息大脑、学习技能、或者别的特别的原因，也会做一些在他人看来是重复性或枯燥的事情。但这是自愿的——只要是有思维能力的人，就不应该被迫做无聊的活儿。）</p><ol start="4"><li>崇尚自由。<br>黑客们是天生的反权威主义者。任何能向你发号施令的人都可以让你停止解决令你着迷的问题，同时，按照权威主义者的一般思路，他通常会给出一些极端愚昧的理由。因此，不论何处，任何权威主义的做法，只要它影响到了你和其他的黑客，你就要和它斗到底。</li></ol><p>（这并非向所有权威挑战。儿童需要监护，罪犯要被看管起来。如果服从命令得到某种东西比起用其他方式得到它更节约时间，黑客可以同意接受某种形式的权威。但这是一个有限度的，斟酌过的的交易；那种权威主义者想要的个人服从是不在考虑范围内的。）</p><p>权威主义者喜欢审查和保密。他们不信任自愿的合作和信息的共享——他们只喜欢由他们控制的所谓“合作”。因此，作为一个黑客，你应该对审查、保密，以及使用武力或欺骗去压迫有行为能力的人们的做法有一种本能的敌意。同时你要有为此信念付出的意愿。</p><ol start="5"><li>态度不能替代能力。<br>作为一名黑客，你必须培养起这些态度。但只具备这些态度并不能使你成为一名黑客，也不能使你成为一个运动健将和摇滚明星。成为一名黑客需要智力、实践、奉献精神、以及辛苦的工作。</li></ol><p>因此，你必须学着忽略态度问题，并尊重各种各样的能力。黑客们不会为那些装模做样的人浪费时间，但他们却非常尊重能力——尤其是从事黑客工作的能力（虽然有能力总归是好事）。如果能具备少有人能掌握的技能就更好了，当然如果你具备一些急需的技能，而这些技能又需要敏锐的思维、高超的技巧、和专注的精神，那就是再好不过了。</p><p>如果你尊重能力，你就会享受到提高自己能力的乐趣——辛苦的工作和奉献将不会是一件苦差事，而是一种紧张的娱乐，这是成为黑客至关重要重要的一点。</p><h2 id="黑客的基本技能"><a href="#黑客的基本技能" class="headerlink" title="黑客的基本技能"></a>黑客的基本技能</h2><ol><li>学习如何编程。<br><code>2. 学习使用开源 Unix 系统。</code>_</li><li>学会使用万维网以及编写 HTML。</li><li>学习英语，如果你的水平不够用的话。<br>黑客态度重要，但技术更加重要。态度无法替代技术，在你被别的黑客称为黑客之前，你必须掌握一些基本的技术作为你随身携带的工具。</li></ol><p>随着新技术的出现和老技术的过时，这个工具包的内容也在不断改变。比如以前机器语言编程也被列在里边，而 HTML 是直到最近才包括进去的。不过现在可以清楚地告诉你包含以下内容：</p><ol><li>学习如何编程。<br>这一条无须多说，当然是最基本的黑客技能。如果你还不会任何编程语言，我建议你从 Python 开始学起。它设计清晰，文档齐全，而且对初学者比较友好。虽然它很适合作为一种入门语言，但它不仅仅只是个玩具；它非常强大、灵活，也适合做大型项目。我在一篇更详细的 Evaluation of Python（译注：Python 试用体验）中有更详细的论述。 Python 网站有很好的入门教程。</li></ol><p>我曾经推荐过将 Java 作为初学的语言，但这则批评改变了我的想法（在里边搜索”The Pitfalls of Java as a First Programming Language” 就知道我的意思了）。作为一名黑客，你不能像人们挖苦的一样，“像水管工人一样装电脑”，你必须知道各个部件的工作原理。现在我觉得可能还是学过 C 和 Lisp 后再学 Java 比较好。</p><p>有一个大体的规律，就是如果你过于偏重使用一种语言，这种语言一方面会成为你得心应手的工具，另一方面也会阻碍你的学习。有这个问题的不只是编程语言，类似 RubyOnRails、CakePHP、以及 Django 的 web 应用框架也有这个问题，它们只会让你肤浅地懂得一些东西，当你碰到难以解决的问题或者需要调试时，你就可能不知所措了。</p><p>如果你想进入正式的编程领域，你将不得不学习 C 语言，它是 Unix 的核心语言。C++ 与 C 非常其他类似；如果你了解其中一种，学习另一种应该不难。但这两种都不适合编程入门者学习。而且事实上，你越避免用C编程，你的工作效率会越高。</p><p>C 语言效率极高，而且占用很少的系统资源。不幸的是，C 的高效是通过你手动做很多底层的管理（如内存管理）来达到的。底层代码都很复杂，而且极易出现 bug，你要花很多的时间调试。而现今的计算机速度如此之快，花时间调试程序通常是得不偿失——比较明智的做法是使用一种运行较慢、效率较低，但能大幅节省你的开发时间的语言。因此，还是选择 Python 吧。</p><p>其他对黑客而言比较重要的语言包括 Perl 和 LISP。从实用的角度来说，Perl 是值得一学的；它被广泛用于动态网页和系统管理中，因此，即便你从不用Perl 写程序，至少也应该学会读懂 Perl。许多人使用 Perl 的理由和 我建议你使用 Python 的理由一样，都是为了避免用 C 完成那些不需要 C 高效率的工作。你会需要理解那些工作的代码的。</p><p>LISP 值得学习的理由不同——最终掌握了它时你会得到丰富的启迪和经验。虽然你实际上很少会用到 LISP，但这些经验会使你在以后的日子里成为一个更好的程序员。</p><p>当然，实际上你最好五种都会（Python，Java，C&#x2F;C++，Perl 和 LISP）。除了是最重要的黑客语言外，它们还代表了截然不同的编程思路和方法，每种都会让你受益非浅。（你可以通过修改 Emacs 编辑器的模式）</p><p>单单学习编程语言并不会让你达到黑客的程度，甚至连程序员的程度都难企及——你需要脱离某种编程语言的素服，学习通过编程解决问题的思路。要成为一个真正的黑客，你需要达到几天就能学会一门编程语言的水平，你可以将文档里的信息和你已经掌握的知识结合起来，很快就学会一门编程语言。这意味着你需要先学会机种思路截然不同的语言才行。</p><p>编程是一个复杂的技能，我无法给你完整的指南来教会你如何编程，不过我可以告诉你，书本和课程也无法教会你如何编程——很多黑客，或者也许几乎所有的黑客，都是靠自学的。你从书本上学到语言的特点——只是一些皮毛，但要使书面知识成为自身技能，你只能通过实践和虚心向他人学习。因此你要做的就是 (a) 读代码，(b) 写代码。</p><p>Peter Novig 是 Google 公司的顶尖黑客之一，而且是最受欢迎的 AI 课本的一名作者。他写了一篇好文章名叫 Teach Yourself Programming in Ten Years（译注：十年教会自己编程），其中的“recipe for programming success”（译注：编程的成功之道）尤其值得一读。</p><p>学习编程就象学习自然语言写作一样。最好的做法是读一些大师的名著，试着自己写点东西，再读些，再写点，再读些，再写点……如此往复，直到你的文章具备范文的力量和感觉为止。</p><p>以前要找适合阅读的好代码并不容易，因为几乎没有大型程序的源代码能让新手练手。这种状况已经戏剧性地发生变化；开源软件、编程工具、和操作系统（全都由黑客写成）现在已经随处可见。让我们在下一个话题中继续讨论……</p><ol start="2"><li>学习使用开源的 Unix 系统。<br>我将假设你已经有一台个人计算机供自己使用了（你可以体会一下这意味着多少东西。早些时候，计算机是如此的昂贵，没有人能买得起。而黑客文化就是在那样的环境下演化来的）。新手们能够朝学习黑客技能迈出的最基本的一步，就是找一版 Linux 或 BSD-Unix，安装在个人电脑上，并且把它跑起来。</li></ol><p>没错，这世界上除了Unix还有其他操作系统。但它们都是以二进制形式发布的——你无法读到它的源代码，也不可能修改它。尝试在运行 DOS、Windows、或 MacOS 的机器上学习黑客技术，就象是穿着骑士铠甲学跳舞。</p><p>除此之外，Unix 还是 Internet 的操作系统。你可以学会上网却不知道 Unix，但你不了解 Unix 就无法成为一名 Internet 黑客。因此，今天的黑客文化在很大程度上是以 Unix 为核心的。（这点并不总是真的，一些很早的黑客对此一直很不满，但 Unix 和 Internet 之间的联系已是如此之强，就连 Microsoft 这样强力的公司也对此也无可奈何。）</p><p>所以, 安装一套 Unix 吧——我个人偏爱 Linux，但还有其他种类共你选择（是的，你可以在同一电脑上同时安装 Linux 和 DOS&#x2F;Windows)。学习它，运行它，鼓捣它。用它上 Internet。阅读它的源代码。修改它的源代码。你会用到很多优秀的编程工具（包括 C， LISP，Python 及 Perl），这些工具在 Windows 下是做梦都没法得到的。你会觉得乐趣无穷。当你有一天成为大师再回顾初学的日子，你会觉得那时学到的东西可真多。</p><p>如果你想了解更多关于学习 Unix 的信息，读一下 The Loginataka（译注：ESR 的另一著作，可以称为黑客大藏经）吧。也许你还想看看 The Art of Unix Programming （译注：Unix 编程艺术，经典著作）。</p><p>你可以访问 Linux Online! 网站，这个网站可以帮你起步。你可以从那里下载到Linux，或者更好的办法是找一个本地的 Linux 用户组，让他们帮你安装 Linux。</p><p>在这份 HOWTO 文档发布后的前十年里，关于 Linux 我写的是，从新人的观点来看，所有的Linux 发行版都差不多，但在 2006-2007 之间，我们终于有了一个最佳选择： Ubuntu。我们可以说各种Linux 发行版各有千秋，但 Ubuntu 是新人最容易上手的一个发行版。</p><p>你可以在 <a href="http://www.bsd.org/">www.bsd.org</a> 找到 BSD Unix 的求助及其他资源。</p><p>Linux 有一种被称为 Live CD 的发行方式，这种发行版会从CD 运行起来，而且不会动到你硬盘里的东西，Live CD 是尝试 Linux 的一个不错的方法。由于光驱读写本来就比较慢，Live CD 的速度一般也会比较慢，不过 Live CD 总归是一个能尝试各种可能性而又不过激的方法。</p><p>我有写一篇关于 Unix 和 Internet 基础的入门文章。</p><p>对于新手，我以前不鼓励你自己独立安装Linux 或者 BSD，现在这些系统的安装工具已经足够好了，就算对新手来说，独立安装操作系统也不是不可能的事。无论如何，我还是推荐你联系本地的 Linux 用户组，向他们寻求帮助，这会进程更加顺利。</p><ol start="3"><li>学会使用万维网以及编写 HTML。<br>黑客文化建造的大多东西都在你看不见的地方发挥着作用。浙西东西可以帮助工厂、办公室、以及大学正常运转起来，但从表面上很难看到它们对非黑客的普通人的生活的影响。而 Web 是一个大大的例外。就连政客也同意，这个庞大耀眼的黑客玩具正在改变整个世界。就算只是因为这个（还有许多其它的原因），Web 也值得你一学。</li></ol><p>这并不是仅仅意味着如何使用浏览器（谁都会），而是要学会如何写 HTML，也就是 Web 的标记语言。如果你不会编程，写HTML会教你一些有助于学习的思考习惯。因此，先完成一个主页。（网上有很多不错的资源，比如 这个 HTML 入门教程。)</p><p>但仅仅拥有一个主页不能使你成为一名黑客。 Web里充满了各种网页。大多数是毫无意义的、毫无信息量的垃圾——界面时髦的垃圾，不过还是垃圾（更多相关信息访问 The HTML Hell Page）。</p><p>要想有价值，你的网页必须有内容——它必须有趣或对其它黑客有帮助。这是下一个话题所涉及的……</p><ol start="4"><li>学习英语，如果你的水平不够用的话。<br>作为一个以英语为母语的美国人，我以前很不情愿提到这点，免得被当做一种文化上的帝国主义。但相当多以其他语言为母语的人一直劝我指出这一点，那就是：英语是黑客文化和 Internet 的工作语言，只有懂英语，你才能在黑客社区顺利做事。</li></ol><p>大概1991年的时候，我就了解到许多黑客在技术讨论中使用英语，甚至有时他们来自同一种母语也在用英文讨论。在现阶段，英语有着比其他语言丰富得多的技术词汇，因此是一个对于工作来说相当好的工具。基于类似的原因，英文技术书籍的翻译通常都不怎么令人满意。（如果有翻译的话）。</p><p>Linus Torvalds 是芬兰人，但他的代码注解是用英语写的（很明显他从没想过其他的可能性）。他流利的英语。是他能够管理全球范围的 Linux 开发人员社区的重要因素。 这是一个值得学习的例子。</p><p>就算你的母语是英语，这也无法保证你的语言技能足够达到黑客的标准。如果你的写作文字不通、语法混乱、错字连篇，包括我在内的大部分的黑客都会忽略你的存在。虽然写作马虎不一定意味着思考也马虎，但我们发现两者的关联性还是挺强的——马虎的头脑对我们来说毫无价值，如果你写作能力不够，就好好学习写作吧。</p><h2 id="提高自己在黑客圈中的地位"><a href="#提高自己在黑客圈中的地位" class="headerlink" title="提高自己在黑客圈中的地位"></a>提高自己在黑客圈中的地位</h2><ol><li>撰写开源软件</li><li>帮助测试并调试开源软件</li><li>发布有用的信息</li><li>帮助维护基础设施的运转</li><li>为黑客文化本身服务<br>和大部分不涉及金钱的文化一样，黑客王国靠声誉运转。你设法解决有趣的问题，但它们到底多有趣，你的解法有多好，是要由那些和你具有同样技术水平，或比你更厉害的人去评判的。</li></ol><p>相应地你需要认识到，当你在玩黑客游戏时，你的分数主要是靠其他黑客对你的技术的评价得到的（这就是为什么只有在其它黑客称你为黑客时，你才算得上是一名黑客）。常人的印象里，黑客是一项独来独往的工作，所以上述评价方式并不为众人所知。另一个黑客文化误区是拒绝承认自我或外部评价是一个人的动力，这种想法在 1990 年代末以后就逐渐衰退了，但现在还有人这么认为。这也是让上述评价方式鲜为人知的原因之一。</p><p>明确地讲，黑客行为就是人类学家所称的“奉献文化”。在这里你不是凭借你对别人的统治来建立地位和名望，也不是靠美貌，或拥有其他人想要的东西，而是靠你的贡献。尤其是贡献你的时间、你的创造、以及你的技术成果。</p><p>要获得其他黑客的尊敬，你可以从下面五种事情着手：</p><ol><li>撰写开源软件<br>第一个方法（也是最重要，最传统的方法）是写些被其他黑客认为有趣或有用的程序，并把程序源代码提供给整个黑客文化圈使用。</li></ol><p>（过去我们称之为“free software （自由软件）”， 但这却使很多不知 free 的精确含义的人感到困惑。现在我们很多人，根据搜索引擎网页内容分析，至少三分之二的人在使用”open-source software，即“开源软件”这个词）。</p><p>黑客领域里最受尊敬的偶像，是那些写了大型的、好用的、用途广泛的软件，并把它们发布出来，使得每人都在使用他软件的人。</p><p>但是从历史方面来讲有一点值得一提。虽然黑客们一直认为开源软件的开发者是真正的黑客，但在 1990 年代中期以前，大部分黑客会把自己的主要时间用来撰写闭源软件，直到我 1996 年开始写这篇 HOWTO 时也是如此。但从 1997 年后开源软件进入了主流，而且改变了这一切。以现在的观点来看，“黑客社群”和“开源开发者”是对这一个社群的两种称呼，但值得记住的是，以前这两者的概念并不完全一样。要了解更多信息，你可以看看 关于黑客、开源、以及自由软件的历史这一节的内容。</p><ol start="2"><li>帮助测试并调试开源软件<br>黑客也尊敬那些使用和测试开源软件的人。这个世界并不完美，我们不可避免地要把大多数的开发时间放在调试阶段。这就是为什么任何有头脑的开源代码的作者都会告诉你好的 beta 测试员象红宝石一样珍贵。好的测试者知道如何清楚描述出错症状，很好地定位错误，能忍受快速发布中的 bug，并且乐意配合做一些例行的诊断性工作。一个优秀的测试者可以让一场旷日持久辛苦不堪的调试大战变成一场有益身心的小打小闹。</li></ol><p>如果你是个新手，试着找一个你感兴趣的正在开发中的程序，做一个好的 beta 测试员。你会自然地从帮着测试，进步到帮着抓 bug，到最后帮着改程序。你会从中学到很多，而且善因种善果，以后别人也会很乐意帮助你。</p><ol start="3"><li>发布有用的信息<br>另一件好事是收集整理有用有趣的信息，做成网页或类似 FAQ 的文档，并且让大家都能看到。</li></ol><p>技术性 FAQ 的维护者会受到和开源代码的作者一样多的尊敬。</p><ol start="4"><li>帮助维护基础设施的运转<br>黑客文化（还有互联网工程方面的发展）是靠志愿者推动的。要使Internet能正常工作，就要有大量枯燥的工作不得不去完成——管理邮件列表和新闻组，维护大型软件库，开发 RFC 和其它技术标准等等。</li></ol><p>做这类事情的人会得到很多尊敬，因为每人都知道这些事情费时颇多，而又不象编程那样有趣。做这些事情需要奉献精神。</p><ol start="5"><li>为黑客文化本身服务<br>最后，你可以为这个文化本身做宣传（例如像我这样，写一个“如何成为黑客”的教程 :-) ）这并不要求在你已经在这个圈子呆了很久，因以上四点中的某点而出名，有一定声誉后才能去做。</li></ol><p>黑客文化没有领袖，这点是确认无疑的。但黑客圈里确实有些文化英雄、部落长者、史学家、还有发言人。如果你在这圈里呆足够长时间，你也许也能成为其中之一。 记住：黑客们不相信他们的部落长者的自夸，因此过分追求这种名誉是危险的。与其奋力追求，不如先摆正自己的位置，等它自己落到你的手中——那时则要做到谦虚和优雅。</p><p>黑客和书呆子(Nerd)的联系<br>和大家普遍认为的相反，并不是只有书呆子才能成为一名黑客。但它确实有帮助，而且许多黑客事实上是书呆子。做一个深居简出的人有助于你集中精力进行十分重要的事情，如思考和编程。</p><p>因此，很多黑客都接受了“geek（奇客）”这个标签，并把它作为骄傲的奖章——这是宣布他们独立于主流社会期望的一种方式（这个标签也是他们喜欢科幻小说和策略型游戏的标记，而这些也是很多黑客喜欢的东西）。1990 年代更多用的称呼是“nerd（书呆子）”，那时“nerd”只带点轻微的贬义，而“geek”则是地地道道的蔑称，而在 2000 年以后，这两者逐渐调转过来了，至少再美国的大众文化中是这样。而到了现在，甚至在非技术人群里，也有不少以 geek 精神为傲的文化团体。</p><p>如果你能集中足够的精力做好黑客工作同时还能有正常的生活，这是件好事。现在要做到这一点比我在 1970 年代还是新手的时候要容易的多；如今主流文化对技术怪人要友善得多。甚至有越来越多的人意识到黑客通常是很好的恋人和配偶的材料。</p><p>如果你因为生活上不如意而迷上做黑客，那也没什么——至少你不会分神了。也许你以后还能找到自己的生活。</p><h2 id="向黑客的格调靠拢"><a href="#向黑客的格调靠拢" class="headerlink" title="向黑客的格调靠拢"></a>向黑客的格调靠拢</h2><p>重申一下，要做一名黑客，你必须深入体验黑客精神。计算你不在计算机边上，你仍然有很多对黑客工作有帮助的事情可做。它们并不能替代真正的编程（没有什么能替代编程），但很多黑客都那么做，并感到它们与黑客的本质存在某些基本的连系。</p><p>学会用母语流畅地写作。尽管很多人认为程序员写不出好文章，但是有相当数量的黑客（包括所有我知道的最棒的黑客）都是很有能力的写手。<br>阅读科幻小说。参加科幻小说讨论会。（这是一个认识黑客和准黑客的好方法）<br>学习一种武术。武术中需要的精神自律能力和黑客在这方面的需求非常相似。黑中最受欢迎的武术是来自亚洲的空手格斗类武术，例如跆拳道、空手道、武术、合气道、柔术等。西式击剑和亚洲剑术也有不少的跟随者。1990 年后期以来，在可以合法使用枪支的地方，射击受欢迎的程度也越来越高了。大部分黑客喜欢的武术类型都是那些强调精神的自律，放松的意识，以及意念的控制，而不仅仅是单纯的力量、运动精神、以及身体的强健。<br>实实在在学习一种冥想修炼。多年以来黑客中最受欢迎的形式是参禅。（很重要的一点是，参禅和宗教可以说是独立的，你不需要接受一种新宗教，或者放弃现有的宗教信仰，就能做参禅的修炼。其他的形式也许也管用，但注意一定要挑那些靠谱的，不需要你相信不着边际的事物的冥想方式来演练。<br>提高自己对双关语和文字游戏的鉴赏能力。<br>如果这些事情有很多你已经在做了，那你可能是天生做黑客的材料。至于为什么偏偏是这些事情，原因并不完全清楚，但它们都涉及用到左－右脑能力的综合，这似乎是关键所在（黑客们既需要清晰的逻辑思维，有时又需要偏离逻辑跳出问题的表象）。</p><p>最后，还有一些不要去做的事情。</p><p>不要使用愚蠢的，哗众取宠的ID或昵称。<br>不要卷入 Usenet（或任何其他地方）的骂战。<br>不要自称为“cyberpunk（网络朋克）”，也不要浪费时间和那些人打交道。<br>不要让你的 email 或者帖子中充满错误的拼写和语法。<br>以上的事情只会为你招来嘲笑。黑客们个个记忆超群——你将需要数年的时间让他们忘记你犯下的错误。</p><p>网名的问题值得深思。将身份隐藏在虚假的名字后是骇客、软件破解者、及其他低等生物幼稚愚蠢的行为。黑客不会做这些事；他们对他们所作的感到骄傲，而且乐于人们将作品与他们的真名相联系。因此, 如果你现在还在使用假名，那就放弃它吧。在黑客文化里假名是失败者的标记。</p><h2 id="关于黑客、开源、以及自由软件的历史"><a href="#关于黑客、开源、以及自由软件的历史" class="headerlink" title="关于黑客、开源、以及自由软件的历史"></a>关于黑客、开源、以及自由软件的历史</h2><p>1996 年我开始写这篇 HOWTO，那时候的大环境和现在很不一样。这里会给你简单介绍一下相关的历史变迁，这样大致可以澄清一下开源软件、自由软件、以及 Linux 和黑客圈的关系。如果你对这些不感兴趣，你可以直接跳过这一节，继续读下面的 FAQ。</p><p>我在这里所描述黑客精神和社会远远早于1990 Linux 出现的时候，我第一次涉足黑客圈是 1976 年，而究其根源则可追溯到20世纪60年代初。但在 Linux 出现之前，大多数黑客使用的操作系统要么是私有的商业版本，要么是自己开发的未得到广泛使用的系统（例如麻省理工学院的 ITS 系统）。虽然那时也有人想要改变这种状况，但他们的努力影响范围相当有限，充其量仅在某个黑客社区有少数忠实用户而已。</p><p>现在所谓“开源”历史和黑客社区的历史几乎一样长，但直到 1985 年前，它只是一种没有固定称谓的习惯做法，而不是一套有理论做后盾，有宣言做前锋的自觉运动。这种状态在 1985年结束了，长老级黑客 Richard Stallman（也被称为“RMS”）将其命名为“自由软件 (Free Software)”。这种命名也是一种宣言的方式，不过大多数黑客社区都不接收这种包含明显思想烙印的标签。因此而大多数现有的黑客社区从来没有接受。结果，“自由软件”这一标签被黑客社群中声音较大的少数人（尤其是 BSD Unix 的相关人士）拒绝掉了，而剩下的大部分人（包括我）虽然也有保留意见，可也还是沿用了这一称谓。</p><p>尽管很多人存在保留意见，RMS 的“自由软件”的大旗也一直举到了 1990 年代中期。直到 Liunx 崛起时它才受到了重大挑战。Linux 给了的开源开发者一个新的自然归宿，很多项目都已我们现称的开源的方式由 Unix 移植到了 Linux 系统中。Linux 的社区也得到了爆炸性增长，成为了一个比以前黑客文化更为庞大，并且异质化的新的群体。RMS 曾今尝试将这一社群也归并到他的“自由软件运动”大旗下，但终究没有成功，原因可以归于 Linux 社区的样性，以及 Linus Torvalds 本人的质疑。Torvalds 公开拒绝了 RMS 的自由软件思想，但还是沿用了“自由软件”这一术语，这也引来了很多年轻黑客的效仿。</p><p>1996年，当我第一次发表这篇 HOWTO 的时候，黑客社团正在围绕着 Linux 和其它几个开源操作系统（尤其是 BSD Unix 的衍生系统）进行着快速的重组。几十年来围绕着闭源系统进行闭源开发的方式还没有开始淡出集体记忆，但在大家看来，这似乎已经是死去的历史了。越来越多的黑客都已经开始注重自己在开源项目（例如 Linux、Apache 等）上的贡献，并将这些贡献当做自己的成就。</p><p>然而在那个时候“开源”这一名词还没有出现。这个名词是 1998 年初才开始出现的，而在出现的半年内，大部分的黑客社区就接受了这一名词，只有少数不接受这一概念的人还在坚持使用“自由软件”这一名词。1998 年以后，或者更准确地说是 2003 年以后，所谓的“hacking” 和 “开源（自由）软件开发”的含义已经非常接近了。从今天的眼光来看，这种区分已经没有意义了，看趋势，这个现状将来也不大可能有多大的改变。</p><p>不管怎样，这段变更的历史还是值得记住的。</p><h2 id="其它资源"><a href="#其它资源" class="headerlink" title="其它资源"></a>其它资源</h2><p>Paul Graham 写了一篇 Great Hackers，还有 Undergraduation 一篇，里边有充满智慧的言论。</p><p>还有一篇叫 How To Be A Programmer 的文章，是这篇文章很好的补充。里边的建议不但包括如何提高编程和其它技术，还包含团队合作的窍门。</p><p>我还写过一篇 A Brief History Of Hackerdom （译注：黑客文化简史）。</p><p>我写了一本 The Cathedral and the Bazaar（译注：大教堂与市集），对于 Linux 及开放源代码文化现象有详细的解释。这种现象在我的另一篇 Homesteading the Noosphere （译注：开拓智域）中还有更直接的阐述。</p><p>Rick Moen 写了一份很好的关于 how to run a Linux user group（译注：如何运营Linux 用户组）的文档。</p><p>我和Rick Moen合作完成了另一份关于 How To Ask Smart Questions（译注：提问的智慧）的文章，可以让在寻求帮助时得到事半功倍的效果。</p><p>如果你想知道 PC、UNIX 及 Internet 基本概念和工作原理，参考 The Unix and Internet Fundamentals HOWTO。</p><p>当你发布软件或者补丁的时候，请遵照 Software Release Practice HOWTO 去做。</p><p>如果你对禅诗感兴趣，也许你还喜欢看这篇 Rootless Root: The Unix Koans of Master Foo</p><h2 id="FAQ（常见问题解答）"><a href="#FAQ（常见问题解答）" class="headerlink" title="FAQ（常见问题解答）"></a>FAQ（常见问题解答）</h2><h3 id="怎样才能知道自己已经是一名够格的黑客？"><a href="#怎样才能知道自己已经是一名够格的黑客？" class="headerlink" title="怎样才能知道自己已经是一名够格的黑客？"></a>怎样才能知道自己已经是一名够格的黑客？</h3><h3 id="你能教我做黑客吗？"><a href="#你能教我做黑客吗？" class="headerlink" title="你能教我做黑客吗？"></a>你能教我做黑客吗？</h3><h3 id="那么，我要如何开始？"><a href="#那么，我要如何开始？" class="headerlink" title="那么，我要如何开始？"></a>那么，我要如何开始？</h3><h3 id="我得什么时候开始学？现在会不会太迟了？"><a href="#我得什么时候开始学？现在会不会太迟了？" class="headerlink" title="我得什么时候开始学？现在会不会太迟了？"></a>我得什么时候开始学？现在会不会太迟了？</h3><h3 id="要学多久才能学会黑客技能？"><a href="#要学多久才能学会黑客技能？" class="headerlink" title="要学多久才能学会黑客技能？"></a>要学多久才能学会黑客技能？</h3><h3 id="Visual-Basic-是好的入门语言吗？"><a href="#Visual-Basic-是好的入门语言吗？" class="headerlink" title="Visual Basic 是好的入门语言吗？"></a>Visual Basic 是好的入门语言吗？</h3><h3 id="你能帮我“黑”掉一个站点吗？或者教我怎么黑它？"><a href="#你能帮我“黑”掉一个站点吗？或者教我怎么黑它？" class="headerlink" title="你能帮我“黑”掉一个站点吗？或者教我怎么黑它？"></a>你能帮我“黑”掉一个站点吗？或者教我怎么黑它？</h3><h3 id="我怎么样才能得到别人帐号的密码？"><a href="#我怎么样才能得到别人帐号的密码？" class="headerlink" title="我怎么样才能得到别人帐号的密码？"></a>我怎么样才能得到别人帐号的密码？</h3><h3 id="我如何入侵-x2F-查看-x2F-监视别人的-Email？"><a href="#我如何入侵-x2F-查看-x2F-监视别人的-Email？" class="headerlink" title="我如何入侵&#x2F;查看&#x2F;监视别人的 Email？"></a>我如何入侵&#x2F;查看&#x2F;监视别人的 Email？</h3><h3 id="我如何才能在IRC聊天室里偷到频道-op-的特权？"><a href="#我如何才能在IRC聊天室里偷到频道-op-的特权？" class="headerlink" title="我如何才能在IRC聊天室里偷到频道 op 的特权？"></a>我如何才能在IRC聊天室里偷到频道 op 的特权？</h3><h3 id="我被黑了。你能帮我避免以后再被攻击吗？"><a href="#我被黑了。你能帮我避免以后再被攻击吗？" class="headerlink" title="我被黑了。你能帮我避免以后再被攻击吗？"></a>我被黑了。你能帮我避免以后再被攻击吗？</h3><h3 id="我的-Windows-软件出现问题了。你能帮我吗？"><a href="#我的-Windows-软件出现问题了。你能帮我吗？" class="headerlink" title="我的 Windows 软件出现问题了。你能帮我吗？"></a>我的 Windows 软件出现问题了。你能帮我吗？</h3><h3 id="我在哪里能找到可以与之交流的真正的黑客？"><a href="#我在哪里能找到可以与之交流的真正的黑客？" class="headerlink" title="我在哪里能找到可以与之交流的真正的黑客？"></a>我在哪里能找到可以与之交流的真正的黑客？</h3><h3 id="你能推荐一些有关黑客的好书吗？"><a href="#你能推荐一些有关黑客的好书吗？" class="headerlink" title="你能推荐一些有关黑客的好书吗？"></a>你能推荐一些有关黑客的好书吗？</h3><h3 id="成为一名黑客我需要擅长数学吗？"><a href="#成为一名黑客我需要擅长数学吗？" class="headerlink" title="成为一名黑客我需要擅长数学吗？"></a>成为一名黑客我需要擅长数学吗？</h3><h3 id="我该从那种语言学起？"><a href="#我该从那种语言学起？" class="headerlink" title="我该从那种语言学起？"></a>我该从那种语言学起？</h3><h3 id="我需要什么样的机器配置？"><a href="#我需要什么样的机器配置？" class="headerlink" title="我需要什么样的机器配置？"></a>我需要什么样的机器配置？</h3><h3 id="我想贡献社区。你可以帮我选一个问题让我下手吗？"><a href="#我想贡献社区。你可以帮我选一个问题让我下手吗？" class="headerlink" title="我想贡献社区。你可以帮我选一个问题让我下手吗？"></a>我想贡献社区。你可以帮我选一个问题让我下手吗？</h3><h3 id="我得因此憎恨和反对-Microsoft-吗？"><a href="#我得因此憎恨和反对-Microsoft-吗？" class="headerlink" title="我得因此憎恨和反对 Microsoft 吗？"></a>我得因此憎恨和反对 Microsoft 吗？</h3><h3 id="开放源代码软件不会使程序员丢饭碗吗？"><a href="#开放源代码软件不会使程序员丢饭碗吗？" class="headerlink" title="开放源代码软件不会使程序员丢饭碗吗？"></a>开放源代码软件不会使程序员丢饭碗吗？</h3><h3 id="我要如何开始？哪里有免费的Unix？"><a href="#我要如何开始？哪里有免费的Unix？" class="headerlink" title="我要如何开始？哪里有免费的Unix？"></a>我要如何开始？哪里有免费的Unix？</h3><h3 id="怎样才能知道自己已经是一名够格的黑客？-1"><a href="#怎样才能知道自己已经是一名够格的黑客？-1" class="headerlink" title="怎样才能知道自己已经是一名够格的黑客？"></a>怎样才能知道自己已经是一名够格的黑客？</h3><h3 id="你可以问自己下面三个问题："><a href="#你可以问自己下面三个问题：" class="headerlink" title="你可以问自己下面三个问题："></a>你可以问自己下面三个问题：</h3><h3 id="1-你能流利地读写代码吗？"><a href="#1-你能流利地读写代码吗？" class="headerlink" title="1. 你能流利地读写代码吗？"></a>1. 你能流利地读写代码吗？</h3><p>你认同黑客社群的目的和价值吗？<br>黑客社群里有没有资深成员称呼你为黑客呢？<br>如果你对这三个问题的答案都是“是”的话，你已经是一名黑客了。如果你只满足其中两项，那就说明你还不够格。</p><p>第一个问题是关于技能的。如果你已经符合本文前面提到的最低需求的话，你也算过关，不过如果你发布过为数不少的开源代码并被社群接受，那你就算满分过关了。</p><p>第二个问题是关于态度的。如果黑客精神的五项基本原则对你来说能有共鸣，而且已经是你处事的方式，你就算过关一半了。这算靠里的一半，靠外的一半和你在黑客社区长期项目上的投入和关联程度有关。</p><p>这里列出了一些项目的不完全列表供你参考：Linux 的改进和用户群扩大对你来说是否重要？你对于自由软件精神是否充满激情？你对于垄断是否有敌意？你是否相信计算机这种工具会让增加世界财富，让这个世界更富有人道主义？</p><p>不过值得注意的一点是，黑客社群有一些特有的政治倾向，其中两条，一条是保卫言论自由权，一种是抵御所谓“知识产权”对于开源社区的侵害。实践这两条的是一些民间组织，例如电子前沿基金会（Electronic Frontier Foundation）就是其中之一。不过虽然如此，黑客们对于有任何明确政治目的的团体都是心怀戒备的，因为我们已经从各种经验教训中学到一点：这些活动只会分裂黑客社团，并让黑客们分心。如果有人以黑客精神为名组织一场首都大游行，那他就完全没有弄明白这点。真正的应对方式也许应该是“闭上嘴巴，给他们看代码”。</p><p>第三个问题有点循环递归的味道。在“什么是黑客”一节我已经讲过，作为一名黑客的意义在于参与某个黑客社群，也就是社交网络的一个亚文化团体，作为内部的贡献成员以及外部的宣传者积极活动。和很久以前相比，黑客群体现在的团结意识和自我意识已经增强了很多。过去三十年来，随着互联网的发展，社交网络逐渐开始发挥举足轻重的作用，而黑客的亚文化团体也更加容易发展和维护了。这种变革的明显一个有代表性的现象是：有的黑客社群现在都有自己专门的文化衫了。</p><p>研究社交网络的社会学家把黑客文化归为“看不见的大学”，而且注意到这些网络社交圈还有所谓的“看门人”——其中的一些核心成员，他们有一定的权威，可以准新成员的进入。所谓的“看不见的大学”本来就是一个松散的非正式组织，所以这些“看门人”也只是这门称呼而已。但不是每个黑客都是“看门人”，这是每个黑客都深刻明白的一点。“看门人”需要有一定的资历和成就，究竟要到什么程度很难讲，但一旦有这样的人出现，每一个黑客都能辨识出来。</p><p>你能教我做黑客吗？<br>自从第一次发布这份文档，我每周都会收到一些请求，（频繁的话一天几封）要我“教会他们做黑客”。遗憾的是，我 没有时间和精力来做这个；我自己的黑客项目，及我作为一个开放源代码倡导者 的四处奔波已经占用了我110%的时间。</p><p>即便我想教你，黑客也依然基本上是一项自行修炼的的态度和技术。 当真正的黑客想帮助你的时候，如果你乞求他们一汤匙一汤匙“喂”你的话，你会发现他们不会尊重你。</p><p>先去学一些东西。显示你在尝试，你能靠自己去学习。然后再去向你遇到的黑客请教特殊的问题。</p><p>如果你发E-mail给一位黑客寻求他的帮助，这是两件首要记住的事情。 第一，写出来的文字显得懒且粗心的人通常非常懒于思考且非常马大哈，不能成为好黑客——因此注意拼写正确，使用正确的语法及发音，否则你可能会无人理睬。 第二，不要试图要求回复到一个ISP帐号，而那个帐号与你 的发信地址不同。这样做的人一般是使用盗用帐号，我们对于回报或者帮助窃贼不感兴趣。</p><p>那么，我要如何开始？<br>对你而言最佳的入门方式也许是去参加 LUG（Linux用户组）的聚会。 你可以找到在 LDP 的综合 Linux 信息页面上找到类似的组织；也许有一个在你家附近的，而且非常有可能与一所大学或学校挂钩。如果你提出要求，LUG 成员兴许会给你一套 Linux，当然此后会帮你安装并带你入门。</p><p>我得什么时候开始学？现在会不会太迟了？<br>你有动力学习的时候就是好时候。大多数人看来都是在15－20岁之间开始感兴趣的，但据我所知，在此年龄段之外的例外也是有的。</p><p>要学多久才能学会黑客技能？<br>这取决于你的聪明程度和努力程度。对于大多数人，只要足够专注，就能在 18 个月到 2 年之间学会一套令人尊敬的技能。但是，不要以为这样就够了；如果你是一个真正的黑客，你要用你的余生来学习和完善你的技术。</p><p>Visual Basic 是好的入门语言吗？<br>既然你问了这个问题，那你肯定是想在 Microsoft Windows 操作系统下学习黑客技能。这本身就不是一个好主意。我前面讲过在 Windows 下 hack 就跟穿着骑士铠甲跳舞一样，我不是在开玩笑。别走这条路，Windows 是一个很低劣的 hack 环境，而且一直如此。</p><p>Visual Basic 有一个特征性问题，就是它不可以被移植到其他平台。虽然也有些 Visual Basic 开源实现的雏形，但实现的只是 ECMA 标准的一个很小的子集。在 Windows 下大部分类库的知识产权都是 Microsoft 独家所有，如果你不是及其小心的话，你的代码将只能在 Microsoft 支持的平台上使用。如果你不打算从 Unix 起步，那你也有更好的语言可选，而且类库质量还更高，例如 Python 就是其中之一</p><p>和其他的 Basic 类语言一样，Visual Basic 这门编程语言的设计也很糟糕，它会教你一些坏的变成习惯。你就别问我细节了，这可是罄竹难书。还是去学一门设计优良的语言吧。</p><p>其中一个坏习惯是让你依赖于单一厂商的函数库、控件及开发工具。一般而言，任何不能够支持至少 Linux 或者某一种 BSD，或其不能支持至少三种以上操作系统的语言，都是一种不适合应付黑客工作的语言。</p><p>你能帮我“黑”掉一个站点吗？或者教我怎么黑它？<br>No。任何读完这份 FAQ 后还问这个问题的人，都是无可救药的蠢材，即使有时间指教我也不会理睬。任何发给我的此类电子邮件都会被忽略或被痛骂一顿。</p><p>我怎么样才能得到别人帐号的密码？<br>这是骇客行为。滚得远远的，白痴。</p><p>我如何入侵&#x2F;查看&#x2F;监视别人的 Email？<br>这是骇客行为。在我面前消失，智障。</p><p>我如何才能在IRC聊天室里偷到频道 op 的特权？<br>这是骇客行为。滚开，笨蛋。</p><p>我被黑了。你能帮我避免以后再被攻击吗？<br>不行。目前为止，每次问我这个问题的，都是一些运行 Microsoft Windows 的菜鸟。不可能有效的保护 Windows 系统免受骇客攻击；太多代码和架构的缺陷使保护 Windows 的努力有如隔靴搔痒。唯一可靠的预防来自转移到 Linux 或其他设计得至少足够安全的系统。</p><p>我的 Windows 软件出现问题了。你能帮我吗？<br>当然。打开 DOS 命令行输入“format c:”。你遇到的任何问题将会在几分钟之内消失。</p><p>我在哪里能找到可以与之交流的真正的黑客？<br>最佳办法是在你附近找一个Unix或Linux的用户组，参加他们的聚会。（你可以在 ibiblio 的 LDP 站点找到一些用户组的链接。）</p><p>（我过去曾说过不能在IRC上找到真正的黑客，但我发觉现在情况有所改变。显然一些真正的黑客的社区像 GIMP 及 Perl，也有IRC频道了。）</p><p>你能推荐一些有关黑客的好书吗？<br>我维护着一份 Linux Reading List HOWTO，也许你会觉得有用。The Loginataka 也大致值得一读。</p><p>关于Python的介绍，请访问在Python站点上的入门教程。</p><p>成为一名黑客我需要擅长数学吗？<br>不用。黑客道很少使用常规的数学或算术，不过你绝对需要能逻辑性地思考和进行精密的推理。尤其是你不会用到微积分或电路分析（我们把这些留给电子工程师们 :-)）。有限数学中的一些可提（包括布尔代数，集合论，组合数学，图论）的背景知识会对你有所帮助。</p><p>更重要的一点：你要有逻辑思维能力，能够以数学家的方式追溯因果。虽然大部分的数学知识对你可能没什么用处，但数学思维的能力对你来说是极其重要的。如果你缺乏这方面的智慧，要做一名黑客恐怕是无望了。如果你缺乏这方面的训练，还是尽早开始吧。</p><p>我该从那种语言学起？<br>如果你还没学过XHTML（HTML最新的表现形式）的话，就从它开始吧。市面上有一大堆的封面精美，宣传得天花乱坠的HTML 书籍，不幸的是质量优秀的几近于无。我最喜欢的是 HTML: The Definitive Guide。</p><p>但HTML 不是一种完整的编程语言。当你准备开始编程时，我推荐从 Python 起步。 你会听到一大群人推荐 Perl，但是 Perl 要难学得多，而且（以我之见）设计得不是很好。</p><p>C 确实重要，但它也比 Python 或 Perl 难多了。不要尝试先学 C。</p><p>Windows用户注意：不要满足于 Visual Basic。它会教给你坏习惯，而且它不可以跨平台移植，只能在Windows下运行。因此还是敬而远之为好。</p><p>我需要什么样的机器配置？<br>过去个人电脑能力相当不足并且内存很小，这给黑客的学习过程设置了人为的障碍。不过 1990 中期以后就不是这样了；任何一台 Intel 486DX50 以上配置的机器都有足够的能力进行开发工作、运行 X 系统、以及进行 Internet 通讯。而且你买到的市面上最小的硬盘都大得足够你使用了。</p><p>选择用来学习的机器时重要的一点是注意配件是否是Linux兼容的（或BSD兼容，如果你选择 BSD 的话）。和刚才提到的一样，大多数现在的机器都是符合的；唯一值得注意的区域在于 modem 和打印机；有些具备为Windows设计的配件的机器不会在Linux下工作。</p><p>你可以查看这份 Linux Hardware Compatibility FAQ。</p><p>我想贡献社区。你可以帮我选一个问题让我下手吗？<br>不行，因为我不知道你的兴趣和擅长领域在哪里。如果你没有内在动力，你就很难坚持下去，所以说，别人只给你的路是行不通的。</p><p>试试这么做吧。在 Freshmeat 网站观察几天，看看里边的项目更新，如果你看到一个看上去很酷而且你也很感兴趣的项目，就加入吧。</p><p>我得因此憎恨和反对 Microsoft 吗？<br>不，你不必如此。不是因为Microsoft不令人讨厌，而是因为黑客文化早在 Microsoft 出现之前就存在了，且将在 Microsoft 成为历史后依然存在。 你耗费在憎恨 Microsoft 的任何力气不如花在爱你的技术上。写好的代码——那会相当有效地打击 Microsoft 又不会让你得到恶报应。</p><p>开放源代码软件不会使程序员丢饭碗吗？<br>目前看起来不太可能，开放源代码软件产业似乎创造了更多的就业机会而不是减少就业机会。如果写一个程序比起不写来是纯经济收益的话，那么在写完后，程序员应该得到报酬不管程序是否是开放源代码。并且，无论写出多么“免费自由”的软件，都存在更多对新的，定制的软件的需求。我有这方面更多的论述，放在放源代码网站资料中。</p><p>我要如何开始？哪里有免费的Unix？<br>在本份文档的某个地方我已经提到过何处可以得到最常用的免费 Unix。要做一名黑客，你需要自己找到激励和动力，还要有自学的能力。现在就开始努力吧……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>domain</title>
      <link href="/2023/04/12/domain/"/>
      <url>/2023/04/12/domain/</url>
      
        <content type="html"><![CDATA[<h1 id="短地址服务设计"><a href="#短地址服务设计" class="headerlink" title="短地址服务设计"></a>短地址服务设计</h1><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><h3 id="1-功能需求："><a href="#1-功能需求：" class="headerlink" title="1.功能需求："></a>1.功能需求：</h3><ol><li>用户可以通过接口将长的URL转换为短的URL。</li><li>用户可以通过短的URL访问原始的URL。</li><li>需要提供统计数据，包括访问量、转换量等。</li></ol><h3 id="2-非功能性需求："><a href="#2-非功能性需求：" class="headerlink" title="2.非功能性需求："></a>2.非功能性需求：</h3><ol><li>高可用性：系统应该能够在故障或异常情况下保持可用。</li><li>高性能：系统应该能够快速响应请求，处理大量并发访问。</li><li>可扩展性：系统应该能够轻松地进行水平扩展以应对用户量的增长。</li><li>安全性：系统应该能够轻松地过滤黑名单用户和ip，防止各种流量和恶意攻击。</li></ol><h3 id="3-扩展要求：（非必需）"><a href="#3-扩展要求：（非必需）" class="headerlink" title="3.扩展要求：（非必需）"></a>3.扩展要求：（非必需）</h3><ol><li>自定义短码长度：用户可以指定生成的短码长度。</li><li>失效时间：短码可以设置过期时间，过期后无法访问。</li></ol><h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p>   <a href="https://github.com/floralatin/domain">https://github.com/floralatin/domain</a></p><h2 id="二、架构设计"><a href="#二、架构设计" class="headerlink" title="二、架构设计"></a>二、架构设计</h2><h3 id="1-架构图"><a href="#1-架构图" class="headerlink" title="1.架构图:"></a>1.架构图:</h3><p>        <span class="lazyload-img-span">        <img              data-src="https://floralatin-blog.oss-cn-beijing.aliyuncs.com/images/projects/domain/architecture_design.png" >        </sapn>      </p><h3 id="2-功能模块："><a href="#2-功能模块：" class="headerlink" title="2.功能模块："></a>2.功能模块：</h3><ol><li>分布式ID生成器：用来生成唯一Id<br>使用算法41位时间+6位业务ID+6位数据中心ID+10位序列号<br>然后转换成62进制并取后8位作为短地址code码</li><li>用户模块：用户创建和token生成</li><li>统计模块：用来统计短地址访问信息，每次访问短地址就会记录客户端的信息</li></ol><h3 id="3-技术栈："><a href="#3-技术栈：" class="headerlink" title="3. 技术栈："></a>3. 技术栈：</h3><p>node + express + typescript + redis + mongodb k8s+ docker 部署</p><h3 id="4-数据库："><a href="#4-数据库：" class="headerlink" title="4. 数据库："></a>4. 数据库：</h3><p>最新的全世界网页统计80亿, 海量数据，使用Nosql来存储</p><ol><li>NoSql 文档存储可以快速添加扩展字段。</li><li>mongodb的分片技术很好的支持海量数据</li></ol><h3 id="5-API设计："><a href="#5-API设计：" class="headerlink" title="5. API设计："></a>5. API设计：</h3><ol><li>定义系统的API接口，包括请求方法、URL、请求参数、返回结果等。</li></ol><h3 id="6-部署方案："><a href="#6-部署方案：" class="headerlink" title="6. 部署方案："></a>6. 部署方案：</h3><p>用k8s和 docker 部署</p><ol><li>容器化隔离了硬件设施环境</li><li>k8s可以很好的对进行管理和快速的动态水平扩展</li></ol><h3 id="7-安全设计："><a href="#7-安全设计：" class="headerlink" title="7. 安全设计："></a>7. 安全设计：</h3><ol><li>API网关</li><li>用户鉴权</li><li>黑名单（ip黑名单和用户黑名单）</li></ol><h3 id="8-性能优化："><a href="#8-性能优化：" class="headerlink" title="8. 性能优化："></a>8. 性能优化：</h3><ol><li>缓存热点数据防止击穿。</li><li>使用布隆过滤器防止缓存穿透</li><li>黑名单以及限流器防止雪崩</li><li>用户的token存放位置</li></ol><h3 id="9-扩展性设计："><a href="#9-扩展性设计：" class="headerlink" title="9. 扩展性设计："></a>9. 扩展性设计：</h3><ol><li>应用服务水平扩展: Docker容器化技术和K8s部署</li><li>数据水平扩展：mongodb的分片</li><li>缓存水平扩展：redis的哈希槽</li></ol><h3 id="10-监控与日志："><a href="#10-监控与日志：" class="headerlink" title="10. 监控与日志："></a>10. 监控与日志：</h3><ol><li>全链路追踪：skywaling 和 traceId</li><li>日志：Grafana 记录以及可视化</li><li>监控到问题可以使用 短息或者微信通知给开发人员</li></ol><h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><h3 id="1-单元测试："><a href="#1-单元测试：" class="headerlink" title="1.单元测试： "></a>1.单元测试：         <span class="lazyload-img-span">        <img              data-src="https://floralatin-blog.oss-cn-beijing.aliyuncs.com/images/projects/domain/test_unit.png" >        </sapn>      </h3><h3 id="2-集成测试："><a href="#2-集成测试：" class="headerlink" title="2.集成测试： "></a>2.集成测试：         <span class="lazyload-img-span">        <img              data-src="https://floralatin-blog.oss-cn-beijing.aliyuncs.com/images/projects/domain/test_integration.png" >        </sapn>      </h3><p>#####(1)生成短地址的用例测试</p><table><thead><tr><th>用例</th><th>输入</th><th>输出</th><th>预期结果</th></tr></thead><tbody><tr><td>不能生成短地址</td><td>1.正常的Url <br>2.header没有设置’Authentication’</td><td>404, “Authentication token missing”</td><td>失败</td></tr><tr><td>不能生成短地址</td><td>1.正常的Url <br>2.header设置错误’Authentication’</td><td>401, “Wrong authentication token”</td><td>失败</td></tr><tr><td>不能生成短地址</td><td>1.非正常的Url（带有脚本注入） <br>2.header设置正确’Authentication’</td><td>400, “Invalid URL”</td><td>失败</td></tr><tr><td>不能生成短地址</td><td>1.没有url参数 <br>2.header设置正确’Authentication</td><td>400, “Invalid URL”</td><td>失败</td></tr><tr><td>不能生成短地址</td><td>1.超级长(超过2082个字符)的的Url <br>2.header设置正确’Authentication’</td><td>400, “Invalid URL”</td><td>失败</td></tr><tr><td>正常生成短地址</td><td>1.正常的Url <br>2.header设置正确’Authentication’</td><td>200, “{url: http:127.0.0.1&#x2F;wqemdawd}”</td><td>成功生成短地址</td></tr><tr><td>正常生成短地址</td><td>1.同样的的Url <br>2.header设置正确’Authentication’</td><td>200, “{url: http:127.0.0.1&#x2F;wqemdawd}”，返回已存在的短地址，不会重新生成</td><td>成功返回短地址</td></tr><tr><td>正常生成短地址</td><td>1.超级长(2083个字符以内)的的Url <br>2.header设置正确’Authentication’</td><td>200, “{url: http:127.0.0.1&#x2F;sdadasd}”</td><td>成功生成短地址</td></tr><tr><td>正常生成短地址</td><td>1.统一的Url <br>2.header设置正确’Authentication’, 使用两个不同的用户</td><td>生成两个同的短地址</td><td>生成两个同的短地址</td></tr><tr><td>正常生成短地址</td><td>1.超级长(2083个字符以内)的的Url <br>2.header设置正确’Authentication’, 使用两个不同的用户,(第一个用户是黑名单)，第二用户不是黑名单</td><td>第一个用户访问返回 403，第二个成功生成短地址，200</td><td>第一个用户不能生成短地址，第二个用户成功生成短地址</td></tr></tbody></table><p>#####(2)重定向长地址的用例测试</p><table><thead><tr><th>用例</th><th>输入</th><th>输出</th><th>预期结果</th></tr></thead><tbody><tr><td>正常跳转到长地址</td><td>1.已经存在的短地址</td><td>302 重定向</td><td>正常跳转</td></tr><tr><td>正常跳转到长地址</td><td>1.同一个已经存在的短地址</td><td>302 重定向，从cache中获取</td><td>正常跳转</td></tr><tr><td>不正常跳转到长地址</td><td>1.不存在的短地址</td><td>404 ‘not found’</td><td>不能正常跳转</td></tr><tr><td>不正常跳转到长地址</td><td>1.错误的短地址code</td><td>400 ‘Invalid Code’</td><td>不能正常跳转</td></tr><tr><td>不正常跳转到长地址</td><td>1.错误的短地址code长度超过8位</td><td>400 ‘Invalid Code’</td><td>不能正常跳转</td></tr><tr><td>不正常跳转到长地址</td><td>1.正常短地址code， 2同一个IP地址 1 秒内请求10次以上</td><td>403 ‘You are blacklisted.’</td><td>不能正常跳转</td></tr><tr><td>不正常跳转到长地址</td><td>1.正常短地址code， 2同一个IP地址一天内请求500次以上</td><td>429 ‘Too Many Requests’</td><td>不能正常跳转</td></tr></tbody></table><h2 id="四、表设计"><a href="#四、表设计" class="headerlink" title="四、表设计"></a>四、表设计</h2><p>使用Mongodb来存储</p><p><strong>Url：</strong></p><table><thead><tr><th>列明</th><th>数据类型</th><th>索引</th><th>描述</th></tr></thead><tbody><tr><td>uid</td><td>string</td><td>主键 唯一 分片键</td><td>记录uid （雪花算法生成）</td></tr><tr><td>code</td><td>string</td><td>Y</td><td>短地址code码（0-8位）</td></tr><tr><td>url</td><td>string</td><td>Y 哈希索引</td><td>原地址</td></tr><tr><td>userUid</td><td>string</td><td>Y</td><td>用户uid</td></tr><tr><td>expiredTime</td><td>Date</td><td>N</td><td>记录uid</td></tr><tr><td>createTime</td><td>Date</td><td>N</td><td>创建时间</td></tr><tr><td>updateTime</td><td>Date</td><td>N</td><td>更新时间</td></tr><tr><td>available</td><td>Boolean</td><td>N</td><td>逻辑删除键</td></tr></tbody></table><p><strong>User：</strong></p><table><thead><tr><th>列明</th><th>数据类型</th><th>索引</th><th>描述</th></tr></thead><tbody><tr><td>uid</td><td>string</td><td>唯一，分片键</td><td>记录uid （雪花算法生成）</td></tr><tr><td>username</td><td>string</td><td>哈希索引，唯一</td><td>用户名</td></tr><tr><td>password</td><td>string</td><td>N</td><td>密码</td></tr><tr><td>salt</td><td>string</td><td>N</td><td>密码加盐</td></tr><tr><td>createTime</td><td>Date</td><td>N</td><td>创建时间</td></tr><tr><td>updateTime</td><td>Date</td><td>N</td><td>更新时间</td></tr><tr><td>available</td><td>Boolean</td><td>N</td><td>逻辑删除键</td></tr></tbody></table><p><strong>Statistics：</strong></p><table><thead><tr><th>列明</th><th>数据类型</th><th>索引</th><th>描述</th></tr></thead><tbody><tr><td>uid</td><td>string</td><td>Y,唯一</td><td>记录 uid</td></tr><tr><td>urlUid</td><td>string</td><td>Y</td><td>url的uid，并作为shardKey</td></tr><tr><td>ip</td><td>string</td><td>N</td><td>用户访问ip</td></tr><tr><td>referer</td><td>string</td><td>N</td><td>跳转的网页</td></tr><tr><td>userAgent</td><td>string</td><td>N</td><td>客户端信息包括浏览器信息，os信息等</td></tr><tr><td>language</td><td>string</td><td>N</td><td>用户使用的语言</td></tr><tr><td>accept</td><td>string</td><td>N</td><td>客户端接受的信息配置</td></tr><tr><td>createTime</td><td>Date</td><td>N</td><td>创建时间</td></tr><tr><td>available</td><td>Boolean</td><td>N</td><td>逻辑删除键</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MBCT</title>
      <link href="/2023/02/05/mbct/"/>
      <url>/2023/02/05/mbct/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker系列（一）</title>
      <link href="/2022/06/02/docker/"/>
      <url>/2022/06/02/docker/</url>
      
        <content type="html"><![CDATA[<p><a href="https://floralatin-blog.oss-cn-beijing.aliyuncs.com/images/docker.pdf">Docker 架构图</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>技术能力</title>
      <link href="/2021/07/02/technical-capability/"/>
      <url>/2021/07/02/technical-capability/</url>
      
        <content type="html"><![CDATA[<h2 id="技术能力："><a href="#技术能力：" class="headerlink" title="技术能力："></a>技术能力：</h2><p>到底什么是技术能力？<br>要解释清楚什么是技术能力还得看透技术能力的本质，从源头上来做剖析。挑选几个程序员日常的工作问题来做个剖析比对，从我们的日常感观中来辨识下哪些是有技术能力的做法，哪些是没啥技术能力的做法。</p><h3 id="两类日常工作"><a href="#两类日常工作" class="headerlink" title="两类日常工作"></a>两类日常工作</h3><p><strong>重复琐碎类工作</strong><br>有一类工作是专门处理其他组技术同学对组内业务的疑惑进行解答，我们称之为daily支持。比如咨询你负责的系统在开发环境有一个报错影响了他们的项目联调是什么原因。这种工作的典型特征就是，随时都可能有人来问你问题，还有可能是同一个问题不同的人来问你很多遍。这类工作称归纳为重复&#x2F;琐碎类工作。这类工作我们来看看几种做法：</p><ul><li>第一种：就事论事，把这个问题回答了结束。到这个程度你只是解决了一个具体的问题。很可惜我们很多技术同学都是处于这个层次。</li><li>第二种：解答完这个问题后即整理成文档，把排查步骤写清楚，提升自己和同组人的工作效率。到这个程度说明你看到并解决了内部效率问题。</li><li>第三种：将此排查问题的方法和逻辑固化为小工具给到咨询的同学去用，让他以后可以自助排查解决，这样既解决了别人的问题也彻底释放了自己和同组人的效能。到这个程度说明你重新定义了效能问题并找到更好提效的办法。</li><li>第四种：将此问题背后根因找到，从业务原理或者产品功能上去找解法。将技术工具抽象为业务功能的完善。到这个程度说明你已经从单纯的技术提效看到了架构合理性问题，并尝试在业务上寻求彻底根治的办法。<br>这四种不同的做法我们可以看出来，即使是这些重复的琐碎类工作，我们也可以从扩大受益面的角度去提炼价值，然后寻求多个层次的解法。在解决问题的过程中自然而然也锻炼了自己多层次的思考和抽象能力。</li></ul><p><strong>抽象复杂类工作</strong><br>还有一类工作是相对抽象和复杂的工作，它的典型特质就是需要只能感受到现象，很难找到根因，没有明确目标和固定解法，需要自己做方案定策略。举个实际中遇到的例子，就是在复杂的系统链路中往往会出现联调效率十分低下的问题，每个研发同学都在抱怨各种各样的问题，但就是没法去根治。面对这样的复杂抽象问题，也有好几种做法：</p><ul><li>第一种：找到抱怨的同学，问一问具体的问题是什么，然后针对性解决。</li><li>第二种：更加广泛收集问题，然后列出来表格，归类分析并安排负责人跟进解决，最后定期跟踪进度。</li><li>第三种：深入分析表格的中的问题并对问题进行抽象，从架构调优和产品功能的角度去寻找原因，并寻找解决这些问题带来的业务价值，并确定目标拆解路径，最后按照任务推进和跟踪进展。</li><li>第四种：从更全局角度去思考此目标与年度目标的关系，与组织发展的关系，思考如何扩大此事的效益，思考如何通过这些事的解决锻炼和培养团队同学。<br>可以看出来这种抽象复杂的工作，其实也有多种做法，看得更加细致是可以看到技术架构的调优，看得有深度可以与目标、组织成长结合在一起。当然也有很一般的做法，那就是纯粹单个问题解决，纯粹是变成项目经理，通过任务列表跟踪进度。</li></ul><h2 id="技巧-架构-价值"><a href="#技巧-架构-价值" class="headerlink" title="技巧-架构-价值"></a>技巧-架构-价值</h2><hr><p>技巧：工程，工具，方法 （研发能力）<br>架构：本质 模型 原则 （协作能力）<br>价值：愿景、目标、组织 （领导能力）</p><hr><p>每日反思，每日总结，每日目标<br>阶段性反思 总结 目标<br>观察现象-发现问题-解决解决-归纳问题</p><p><strong>单体力量：</strong><br>提高认知-行动验证-归纳总结 这是一个循环<br>能力和原则是核心。</p><p><strong>团队力量：</strong><br>结构化沟通<br>知道每个人的擅长和短处<br>组合每个达成目标。<br>沟通-协作是核心。</p><p><strong>领导能力：</strong><br>对问题本质的分析并有宏大的愿景<br>超越普通人百倍的认知<br>拥有实现目标的资源<br>核心是什么：等我做到了再写。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目制学习</title>
      <link href="/2020/08/07/pbl/"/>
      <url>/2020/08/07/pbl/</url>
      
        <content type="html"><![CDATA[<p><strong>项目制学习是一种基于项目实践的学习方法。它的核心思想是通过参与实际项目的过程来获得知识和技能，从而提高学习效果。</strong></p><p>在项目制学习中，学生通常会被组织成小组，每个小组负责一个实际的项目。在项目的过程中，学生需要与其他小组成员合作，制定计划、分配任务、解决问题、评估成果等，从中获得知识和技能的锻炼。同时，学生还需要不断反思自己的行动和学习，以不断提高。</p><p>相对于传统的课堂学习，项目制学习的优势在于它可以让学生更加深入地了解实际问题，并锻炼实际解决问题的能力。此外，它还可以培养学生的团队协作能力、沟通能力和领导能力等重要的软技能。</p><p>在实施项目制学习时，需要充分考虑项目的设计和管理，确保项目具有一定的难度和挑战性，同时要提供必要的支持和指导，以帮助学生克服困难，取得成功。</p><p>（植根于中国，面向未来的小-初-高阶段创新教育项目，致力于培养「内心丰盈的个体、积极行动的公民」。 全面实践素养本位教育，提供不仅习得知识、更培养核心能力的课程体系； 构建基于学习者自我探索实现个性化发展的支持系统；共建温暖而自由的社区生活 从一可走出来的每一个人都可以支持人类命运共同体的可持续发展，善及万物，探求真理，坚毅笃行。</p><p>以「实践知识和技能」为基础，以「解决真实世界问题」为目标，通过基于项目的学习场景，学习者解决真实世界的问题。<br>通过项目制学习：可以获得 可持续发展的知识,合作技能,自主学习技能,项目管理技能,沟通技能,解决问题的技能。）</p><p><strong>主题选择</strong>：选择一个主题，确保它与学生的兴趣和学习目标相关，并且与实际问题密切相关。例如，可以选择“环保”、“社区发展”、“科技创新”等主题。</p><p><strong>团队组建</strong>：将学生分成小组，每个小组最好由4-6人组成。小组成员应该具有不同的背景和技能，以便能够相互补充。学生也可以选择自己的小组成员，但是教师也可以为学生分配小组。</p><p><strong>项目设计</strong>：根据主题和学习目标，设计一个具有一定难度和挑战性的项目，包括项目目标、任务分配、时间表和预算。教师可以提供一些初始的设计方案，但是学生应该能够为项目做出自己的贡献。</p><p><strong>实施过程</strong>：在项目实施的过程中，教师应该充当指导者和监督者的角色，帮助学生解决问题，提供必要的支持和资源，同时确保学生能够按时完成项目。学生应该紧密合作，共同解决问题，分享经验和知识。</p><p><strong>项目评估</strong>：在项目完成后，应该对项目进行评估，以便确定学生是否已经达到学习目标。评估可以采用多种方式，例如展示、演示、口头报告等。此外，学生也应该对自己的学习和行动进行反思，以便不断提高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">主题：环保</span><br><span class="line"></span><br><span class="line">目标：通过实施一个环保项目，学生将学习如何评估环境问题，提出解决方案，制定计划，协调资源，并实施项目。</span><br><span class="line"></span><br><span class="line">任务分配：</span><br><span class="line"></span><br><span class="line">小组1：环境问题评估和解决方案提出</span><br><span class="line"></span><br><span class="line">小组2：计划制定和资源协调</span><br><span class="line"></span><br><span class="line">小组3：项目实施和结果评估</span><br><span class="line"></span><br><span class="line">时间表：</span><br><span class="line"></span><br><span class="line">周一：小组会议，讨论环境问题和解决方案</span><br><span class="line"></span><br><span class="line">周二-周三：小组工作，制定计划，协调资源</span><br><span class="line"></span><br><span class="line">周四：小组汇报，教师指导</span><br><span class="line"></span><br><span class="line">周五-周六：项目实施</span><br><span class="line"></span><br><span class="line">周日：项目评估，小组总结报告</span><br><span class="line"></span><br><span class="line">预算：1000元（由教师提供）</span><br><span class="line"></span><br><span class="line">在这个例子中，学生将通过实施一个环保项目，例如在学校或社区内实施垃圾分类和回收计划，</span><br><span class="line">来学习如何评估环境问题，提出解决方案，制定计划，协调资源，并实施项目。每个小组将负</span><br><span class="line">责不同的任务，例如小组1将评估环境问题，并提出解决方案，小组2将制定计划，并协调资源，</span><br><span class="line">小组3将负责实施项目和评估结果。在项目实施过程中，学生将需要合作，协作解决问题，分享</span><br><span class="line">知识和经验，并通过项目评估和总结报告来反思自己的学习和行动，从中获得更多的经验和技能。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式-一致性模型</title>
      <link href="/2020/03/02/consistency-model/"/>
      <url>/2020/03/02/consistency-model/</url>
      
        <content type="html"><![CDATA[<h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p>为了描述现实世界中：时间, 事件，顺序。</p><p><strong>全序关系（线性顺序）：</strong><br>对于 a，b，c 属于集合 S</p><blockquote><p>完全性：a&lt;&#x3D;b 或 b&lt;&#x3D;a<br>反对称性：若 a&lt;&#x3D;b 且 b&lt;&#x3D;a 则 a&#x3D;b<br>传递性：若 a&lt;&#x3D;b 且 b&lt;&#x3D;c 则 a&lt;&#x3D;c</p></blockquote><p><strong>偏序关系：</strong><br>对于 a，b，c 属于集合 S</p><blockquote><p>自反性：a&lt;&#x3D;a<br>反对称性：若 a&lt;&#x3D;b 且 b&lt;&#x3D;a 则 a&#x3D;b<br>传递性：若 a&lt;&#x3D;b 且 b&lt;&#x3D;c 则 a&lt;&#x3D;c</p></blockquote><p><strong>物理时钟：</strong><br>计算机中的时钟是一个物理硬件通常称为计时器，计算机的计时器通常是一个石英晶体管。石英晶体管以一定的频率振荡。然后有两个寄存器与每个石英晶体相联，一个是计数器，另一个是保持寄存器。石英晶体振荡使得计数器减1。当计数器为0时产生一个中断，然后计数器从保持寄存器中重新装入初始值。计数器产生的中断称为时钟滴答。当产生一个中断时，操作系统就会响应中断并调用中断处理程序将时钟存储器中的值加1。计算中物理时钟的的主要问题是时钟偏移（clock skew）。通俗点描述时钟偏移就是钟摆摆动的偏移变慢或者变快或者时快时慢导致时钟不同步。<br>对单台机器没有影响，在分布式系统中，整个分布式系统中的时钟不同步的话会导致依赖时钟同步的程序有问题，就会产生时序不一致。<br>解决物理时钟不同步的算法（网络时间协议、Berkeley算法、Critian算法）</p><p><strong>逻辑时钟：</strong><br>与物理时钟不同逻辑时钟关注点在事件先后的相对性 ，这个时间不一定与实际时间相同。<br>逻辑时钟的概念是由著名的分布式系统科学家 Leslie Lamport (2013年图灵奖得主) 提出的， 在他的那篇著名的论文「Time, Clocks and the Ordering of Events in a Distributed System」 的介绍上，lamport提到了著名的狭义相对论：</p><blockquote><p>Special relativity teaches us that there is no invariant total ordering of events in space-time;  different observers can disagree about which of two events happened first. There is only a partial order in which an event e1 precedes an event e2 iff e1 can causally affect e2.<br>               Leslie Lamport 《Time, Clocks and the Ordering of Events …》</p></blockquote><p>爱因斯坦的狭义相对论告诉我们，时空中不存在绝对的全序事件顺序，不同的观察者可能对哪个事件是先发生的无法达成一致。 但是有偏序关系存在，当事件e2是由事件e1引起的时候，e1和e2之间才有先后关系。</p><p><strong>【拓展】</strong></p><blockquote><p>向量时钟<br>版本向量<br>区间树时钟</p></blockquote><h2 id="什么是一致性："><a href="#什么是一致性：" class="headerlink" title="什么是一致性："></a>什么是一致性：</h2><p>定义为:<br>Validity：有效性（合法性），如果所有节点中的数据只有 0 和 1 两种，那么最后达成一致的决议一定是 0 和 1 这两种的一个。不可能说算法莫名其妙的达成一个一致的数值如 -1。<br>Agreement：一致性，所有节点达成一致的决议。<br>Termination：终止性，所有正常运行的节点最终都能够做出决议。</p><h2 id="线性一致性-Linearizability-（原子一致性）"><a href="#线性一致性-Linearizability-（原子一致性）" class="headerlink" title="线性一致性 (Linearizability)（原子一致性）"></a>线性一致性 (Linearizability)（原子一致性）</h2><p>线性一致性利用了事件的提交顺序，它保证任何读操作得到的数据，其顺序跟读&#x2F;写事件的提交顺序一致。<br>要求：全局时钟 全序</p><h2 id="顺序一致性-Linearizability"><a href="#顺序一致性-Linearizability" class="headerlink" title="顺序一致性 (Linearizability)"></a>顺序一致性 (Linearizability)</h2><p>只保证每个节点上的事件顺序一致，对节点之间的事件顺序只有非常宽松的要求。<br>要求：单节点 全序 多节点 偏序</p><h2 id="因果一致性-Linearizability"><a href="#因果一致性-Linearizability" class="headerlink" title="因果一致性 (Linearizability)"></a>因果一致性 (Linearizability)</h2><p>同样只保证每个节点上的事件顺序一致，但是对节点之间的事件顺序的要求比顺序一致性更宽松<br>要求：逻辑时钟 偏序</p><h2 id="最终一致性-Linearizability"><a href="#最终一致性-Linearizability" class="headerlink" title="最终一致性 (Linearizability)"></a>最终一致性 (Linearizability)</h2><p>总会存在一个时刻（而不是立刻），系统达到一致的状态</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式-理论</title>
      <link href="/2020/03/01/distributed-theory/"/>
      <url>/2020/03/01/distributed-theory/</url>
      
        <content type="html"><![CDATA[<h2 id="CAP-定理-（同步网络模型和异步网络模型）"><a href="#CAP-定理-（同步网络模型和异步网络模型）" class="headerlink" title="CAP 定理 （同步网络模型和异步网络模型）"></a>CAP 定理 （同步网络模型和异步网络模型）</h2><p>CAP 定理是分布式领域中闻名遐迩的一个基石定理。<a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86">CAP 定理</a>又叫做布鲁斯定理, 该定理源于埃里克·布鲁尔在2000年的分布式计算原理研讨会上提出的一个猜想， 在2002年麻省理工学院的Gilbert和Lynch发表了证明[1]，使之成为一个定理：分布式系统不可能同时保证 一致性(Consistency)、 可用性(Availability) 和 分区容忍性(Partition tolerance)。</p><p>这个定理也可以表达为： 在网络分区发生的情况下，分布式系统不能同时保证一致性和可用性。 除非是单节点系统，否则无法同时保证 CA。</p><h4 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性 | Consistency"></a>一致性 | Consistency</h4><p><strong>定义：分布式系统中多个节点的数据返回始终一致的性质。(Consistency &#x3D; two reads return the same value.)</strong></p><p>Gilbert 和 Lynch 对一致性的描述是这样的:</p><blockquote><p>Any read operation that begins after a write operation completes must return that value, or the result of a later write operation. All nodes see the same data at the same time.</p></blockquote><blockquote><p>在一个具有一致性的分布式系统中，一旦一个对任一节点的写入返回成功，后续对这个系统中其他任意节点的读操作都应该可以返回这个更新的值。所有节点在同一时刻的看到的数据是一样的。</p></blockquote><p><strong>分类：</strong></p><blockquote><p>弱一致性: 向系统写入一个值后，后续的读操作可能读出来，也可能读不出来。(After a write, reads may or may not see it.)</p></blockquote><blockquote><p>最终一致性: 向系统写入一个值后，后续立刻的读操作可能读不出来，但是在某个时间段后，读取一定成功。 例如，读写分离的关系型数据库。(After a write, reads will eventually see it.)</p></blockquote><blockquote><p>强一致性: 向系统写入一个值后，后续任意时刻的读取一定成功。(After a write, reads will always see it.)</p></blockquote><h4 id="可用性-Availability"><a href="#可用性-Availability" class="headerlink" title="可用性 | Availability"></a>可用性 | Availability</h4><p><strong>定义: 在分布式系统中，可用性是指每次请求都能获取到非错的响应的性质。（Availability &#x3D; Reads and writes always succeed.）</strong></p><p>Gilbert 和 Lynch 对一致性的描述是这样的:</p><blockquote><p>Every request received by a non-failing node in the system must result in a response. That is, any algorithm used by the service must eventually terminate.</p></blockquote><blockquote><p>如果客户端发送一个请求给分布式系统中的一个无故障的节点， 这个节点必须回复请求。 就是，系统所用的任何算法都必须最终结束。</p></blockquote><p><strong>怎么样提高可用性：</strong><br>冗余和故障转移(参考高可用的知识)</p><h4 id="分区容忍性-Partition-tolerance"><a href="#分区容忍性-Partition-tolerance" class="headerlink" title="分区容忍性 | Partition tolerance"></a>分区容忍性 | Partition tolerance</h4><p><strong>定义：当两个节点之间的网络不再连通，相当于分成了几块分区，所以叫做分区现象。如果不能在通信时限内达成数据一致，就意味着发生了分区。分区容忍性是指即使分区现象发生，系统仍然可以工作的性质。（Continues to function even if there is a “partition”.）</strong></p><h4 id="为什么不能同时满足：-一致性-可用性-分区容忍性"><a href="#为什么不能同时满足：-一致性-可用性-分区容忍性" class="headerlink" title="为什么不能同时满足： 一致性 可用性 分区容忍性"></a>为什么不能同时满足： 一致性 可用性 分区容忍性</h4><p>   原因：网络是不稳定的。 网络中的节点也不稳定，丢包、延迟、中断都糊发生。所以导致分区现象在现实网络中不可避免，也就是说，现实中我们只能在 C 和 A中做选择。</p><h2 id="BASE-定理"><a href="#BASE-定理" class="headerlink" title="BASE 定理"></a>BASE 定理</h2><p>有eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结：<br>BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）</p><p><strong>基本可用（Basically Available）</strong><br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p><p><strong>软状态（ Soft State）</strong><br>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。</p><p><strong>最终一致性（ Eventual Consistency）</strong><br>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p><h2 id="FLP-定理-（异步网络模型中）"><a href="#FLP-定理-（异步网络模型中）" class="headerlink" title="FLP 定理 （异步网络模型中）"></a>FLP 定理 （异步网络模型中）</h2><p>由Fischer、Lynch和Patterson三位科学家于1985年发表的论文《Impossibility of Distributed Consensus with One Faulty Process》：<br><strong>在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法。</strong></p><p>[参考]<br><a href="https://www.inlighting.org/archives/understand-flp-impossibility">【理解FLP论文】</a> <a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf">【FLP论文】</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式-网络\错误模型</title>
      <link href="/2020/02/17/distributed-network-fault/"/>
      <url>/2020/02/17/distributed-network-fault/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式系统中的网络模型"><a href="#分布式系统中的网络模型" class="headerlink" title="分布式系统中的网络模型"></a>分布式系统中的网络模型</h2><p><strong>同步网络:</strong></p><ol><li>所有节点的时钟漂移有上限。</li><li>网络的传输时间有上限。</li><li>所有节点的计算速度一样。</li></ol><p><strong>异步网络：</strong></p><ol><li>节点的时钟漂移无上限。</li><li>消息的传输延迟无上限。</li><li>节点计算的速度不可预料。</li></ol><h2 id="分布式系统中的故障模型"><a href="#分布式系统中的故障模型" class="headerlink" title="分布式系统中的故障模型"></a>分布式系统中的故障模型</h2><p><strong>拜占庭错误:</strong><br> 这是最难处理的情况, 一个节点压根就不按照程序逻辑执行, 对它的调用会返回给你随意或者混乱的结果. 要解决拜占庭式故障需要有同步网络, 并且故障节点必须小于1&#x2F;3或者消息传递过程中不可篡改。<br> 算法：PBFT<br><strong>崩溃恢复错误:</strong><br>它比byzantine类故障加了一个限制, 那就是节点总是按照程序逻辑执行, 结果是正确的. 但是不保证消息返回的时间. crash的情况还要分健忘(amnesia)和非健忘的两种情况.对于健忘的情况, 是指这个crash的节点重启后没有完整的保存crash之前的状态信息, 非健忘是指这个节点crash之前能把状态完整的保存在持久存储上, 启动之后可以再次按照以前的状态继续执行和通信。<br>算法： Paxos和Raft<br><strong>omission failures:</strong><br>比crash-recovery多了一个限制, 就是一定要非健忘。<br><strong>崩溃停止错误:</strong><br>也叫做crash failure或者fail-stop failures, 它比omission failure多了一个故障发生后要停止响应的要求。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>书单</title>
      <link href="/2019/12/23/sum-up-2019/"/>
      <url>/2019/12/23/sum-up-2019/</url>
      
        <content type="html"><![CDATA[<h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><p><strong><a href="https://floralatin-blog.oss-cn-beijing.aliyuncs.com/books/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js.pdf">深入浅出Nodejs</a></strong></p><p><strong><a href="https://floralatin-blog.oss-cn-beijing.aliyuncs.com/books/%E9%AB%98%E6%80%A7%E8%83%BDMySQL.pdf">高性能MySQL</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>auth</title>
      <link href="/2018/07/28/auth/"/>
      <url>/2018/07/28/auth/</url>
      
        <content type="html"><![CDATA[<h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><p><strong>你将了解-10种鉴权方法</strong></p><h2 id="什么是认证、授权、鉴权、权限控制"><a href="#什么是认证、授权、鉴权、权限控制" class="headerlink" title="什么是认证、授权、鉴权、权限控制"></a>什么是认证、授权、鉴权、权限控制</h2><p><strong>认证(Identification)</strong><br>是指根据声明者所特有的识别信息，确认声明者的身份。<br>比如我们常见的认证技术：</p><ul><li>用户名和密码</li><li>用户手机：手机短信、手机二维码扫描、手势密码</li><li>用户的电子邮箱</li><li>用户的生物学特征：指纹、语音、眼睛虹膜</li></ul><p><strong>授权(Authorization)</strong><br>在信息安全领域是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便对资源的相关操作。<br>比如： web 服务器的 session 机制、web 浏览器的 cookie 机制、颁发授权令牌（token）等都是一个授权的机制。</p><p><strong>鉴权(Authentication)</strong><br>在信息安全领域是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。</p><p><strong>权限控制(Access&#x2F;Permission Control)</strong><br>将可执行的操作定义为权限列表，然后判断操作是否允许&#x2F;禁止。<br>对于权限控制，可以分为两部分进行理解：一个是权限，另一个是控制。权限是抽象的逻辑概念，而控制是具体的实现方式。</p><p><strong>认证-&gt;授权-&gt;鉴权-&gt;权限控制</strong></p><h2 id="HTTP-基本鉴权"><a href="#HTTP-基本鉴权" class="headerlink" title="HTTP 基本鉴权"></a>HTTP 基本鉴权</h2><h2 id="Session-Cookie-鉴权"><a href="#Session-Cookie-鉴权" class="headerlink" title="Session-Cookie 鉴权"></a>Session-Cookie 鉴权</h2><h2 id="Token-鉴权"><a href="#Token-鉴权" class="headerlink" title="Token 鉴权"></a>Token 鉴权</h2><h2 id="JWT（JSON-Web-Token）鉴权"><a href="#JWT（JSON-Web-Token）鉴权" class="headerlink" title="JWT（JSON Web Token）鉴权"></a>JWT（JSON Web Token）鉴权</h2><h2 id="单点登录（Single-Sign-On）"><a href="#单点登录（Single-Sign-On）" class="headerlink" title="单点登录（Single Sign On）"></a>单点登录（Single Sign On）</h2><p><strong>同域单点登录</strong></p><ol><li>客户端： 用户访问某个子系统时（例如 a.baidu.com），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录；</li><li>服务端： 登录认证后，服务端把登录用户的信息存储于 Session 中，并且附加在响应头的 Set-Cookie 字段中，设置 Cookie 的 Domain 为 .baidu.com ；</li><li>客户端：用户访问某个子系统（例如 b.baidu.com），客户再次发送请求时，携带主域名 Domain 下的 Cookie 给服务器，此时服务端就可以通过该 Cookie 来验证登录状态了；</li></ol><p><strong>非同域单点登录</strong></p><ol><li><p>客户端： 开始访问系统 A；</p></li><li><p>系统 A： 发现用户未登录，重定向至 CAS 认证服务（sso.com），同时 URL 地址参数携带登录成功后回跳到系统 A 的页面链接（sso.com&#x2F;login?redirectUrl&#x3D;a.baidu.com)</p></li><li><p>CAS 认证服务： 发现请求 Cookie 中没有携带登录的票据凭证（TGC），所以 CAS 认证服务判定用户处于 未登录 状态，重定向用户页面至 CAS 的登录界面，用户在 CAS 的登录页面上进行登录操作。</p></li><li><p>客户端： 输入用户名密码进行 CAS 系统认证；</p></li><li><p>CAS 认证服务： 校验用户信息，并且 生成 TGC 放入自己的 Session 中，同时以 Set-Cookie 形式写入 Domain 为 sso.com 的域下 ；同时生成一个 授权令牌 ST (Service Ticket) ，然后重定向至系统 A(a.baidu.com) 的地址，重定向的地址中包含生成的 ST（重定向地址：a.baidu.com?token&#x3D;ST-345678）</p></li><li><p>系统 A： 拿着 ST 向 CAS 认证服务发送请求，CAS 认证服务验证票据 (ST) 的有效性。验证成功后，系统 A 知道用户已经在 CAS 登录了（其中的 ST 可以保存到 Cookie 或者本地中），系统 A 服务器使用该票据 (ST) 创建与用户的会话，称为局部会话，返回受保护资源；到这里客户端就可以跟系统 A 愉快的交往啦 ~</p></li><li><p>客户端： 开始访问系统 B(b.baidu2.com)；</p></li><li><p>系统 B： 发现用户未登录，重定向至 SSO 认证服务，并将自己的地址作为参数传递，并附上在 sso.com 域下的 cookie 值是第五步生成的 TGC；</p></li><li><p>CAS 认证服务： CAS 认证服务中心发现用户已登录，跳转回系统 B 的地址，并附上票据 (ST) ;</p></li><li><p>系统 B： 拿到票据 (ST)，去 CAS 认证服务验证票据 (ST) 的有效性。验证成功后，客户端也可以跟系统 B 交往了 ~</p></li></ol><h2 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><h2 id="联合登录和信任登录"><a href="#联合登录和信任登录" class="headerlink" title="联合登录和信任登录"></a>联合登录和信任登录</h2><h2 id="唯一登录"><a href="#唯一登录" class="headerlink" title="唯一登录"></a>唯一登录</h2><h2 id="扫码登录"><a href="#扫码登录" class="headerlink" title="扫码登录"></a>扫码登录</h2><h2 id="10-一键登录（适用于原生APP）"><a href="#10-一键登录（适用于原生APP）" class="headerlink" title="10. 一键登录（适用于原生APP）"></a>10. 一键登录（适用于原生APP）</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
